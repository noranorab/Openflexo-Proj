namespace "file:/C:/Users/PC/Desktop/TelecomParis/internship%202A/" as _;

use org.openflexo.technologyadapter.xml.XMLModelSlot as XML;
use org.openflexo.foundation.fml.rt.FMLRTModelSlot as FMLRT;

import org.openflexo.foundation.fml.VirtualModel;
import org.openflexo.technologyadapter.xml.model.typed.XMLModel;
import org.openflexo.technologyadapter.xml.model.typed.XMLIndividual;
import org.openflexo.technologyadapter.xml.metamodel.XSDMetaModel;
import org.openflexo.technologyadapter.xml.metamodel.XMLComplexType;
import java.lang.String;
// import wcet.util.WcetMath;  // Uncomment if you actually use it

/* === XSD meta-models (URIs or file-based) ================================ */
/* OTAWA Cache XSD (icache / dcache). If you prefer local file, you can use:
   import XSDMetaModel OTAWA_CACHE from [_ + "xmlFiles/OtawaCache.xsd"];
*/

/* Heptane WCET XSD (CACHE element has named type HeptaneCacheType).
   If you prefer local file, use:
   import XSDMetaModel HEPTANE_WCET from [_ + "xmlFiles/HeptaneWCET.xsd"];
*/
//import XSDMetaModel HEPTANE_WCET   from ["http://mem4csd.telecom-paris.fr/HeptaneWCET"];
import XSDMetaModel OTAWA_CACHE    from ["http://mem4csd.telecom-paris.fr/OtawaCache"];
import XSDMetaModel HEPTANE_WCET from ["http://mem4csd.telecom-paris.fr/HeptaneWCET"];

/* === XML complex types ==================================================== */
//import XMLComplexType CACHE_CONFIG  from [OTAWA_CACHE:"dcache"];

import XMLComplexType ICACHE_TYPE  from [OTAWA_CACHE:"icache"];
import XMLComplexType HCACHE_TYPE  from [HEPTANE_WCET:"HeptaneCacheType"];
import XMLComplexType CONFIGURATION_TYPE   from [HEPTANE_WCET:"CONFIGURATION"];
import XMLComplexType ARCHITECTURE_TYPE   from [HEPTANE_WCET:"ARCHITECTURE"];
//import XSDMetaModel HEPTANE_WCET2 from ["http://mem4csd.telecom-paris.fr/HeptaneWCET"];

//import XMLComplexType CONFIG_TYPE from [OTAWA_CACHE:"CacheConfigType"];

/* === FML typedefs to make roles strongly typed =========================== */
typedef XMLIndividualType(xsdType=ARCHITECTURE_TYPE) as HeptaneCache;
typedef XMLIndividualType(xsdType=CONFIGURATION_TYPE) as HeptaneConfiguration;
typedef XMLIndividualType(xsdType=ICACHE_TYPE) as OtawaICache;
typedef XMLIndividualType(xsdType=ARCHITECTURE_TYPE) as Architecture;

/* =========================================================================
   All-in-one VM: resources, roles, sync logic, and a small workflow API
   ========================================================================= */
@URI("file:/C:/Users/PC/Desktop/TelecomParis/internship%202A/HeptaneTool.fml")
@Author("PC")
public model HeptaneTool {

  /* ---- Bind the two XML instance resources (the actual XML files) ---- */
    XMLModel otawaCacheRes  with XMLModelSlot(metaModel=OTAWA_CACHE);
   XMLModel heptaneCacheRes with XMLModelSlot(metaModel=HEPTANE_WCET);
  /* ---- Federation roles: the two cache individuals we synchronize ---- */
  XMLIndividualType(xsdType=HCACHE_TYPE)  hCache with XMLIndividualRole(container=heptaneWCETRes,xsdType=HCACHE_TYPE);
  OtawaICache   iCache with XMLIndividualRole(container=otawaCacheRes,  xsdType=ICACHE_TYPE);
  HeptaneConfiguration  configuration with XMLIndividualRole(container=heptaneWCETRes, xsdType=CONFIGURATION_TYPE );
    
  /* ---------------------------------------------------------------------
     Constructors / connectors
     --------------------------------------------------------------------- */

   CacheView cacheView with ConceptInstance(virtualModelInstance=this);
   Cache cache with ConceptInstance(virtualModelInstance=this);
	
  create(Resource<XMLModel> heptaneRes, Resource<XMLModel> otawaRes) {
    connect heptaneCacheRes using parameters.heptaneRes;
    connect otawaCacheRes  using parameters.otawaRes;
    //XMLIndividual arch = configuration.getPropertyValue("ARCHITECTURE");
    //iCache = (OtawaICache)otawaCacheRes.root.icache;
   // XMLIndividual config = otawaCacheRes.getIndividualWithUUID("otawa::hard::Cache");
   
   configuration =(HeptaneConfiguration)heptaneCacheRes.root;
   //hCache = configuration.architecture.caches;
//log "architecture: " + ARCHITECTURE;
   // for (HeptaneCache cache : configuration.architecture.caches) {
     //hCache =cache;
//}

  }

   
  /* =====================================================================
     Federation concept: canonical cache properties + sync methods
     ===================================================================== */
  public concept Cache {

    
    /* Heptane side (attributes on <CACHE .../>) */
    
    Integer h_nbsets  {
      Integer get() { return hCache.nbsets; 
}
      set(Integer value) { hCache.nbsets = value; }
    };

    Integer h_nbways  {
      Integer get() { return hCache.nbways; 
}
      set(Integer value) { hCache.nbways = value; }
    };

    Integer h_cachelinesize  {
      Integer get() { return hCache.cachelinesize; 
}
      set(Integer value) { hCache.cachelinesize = value; }
    };

    Integer h_latency  {
      Integer get() { return hCache.latency; 
}
      set(Integer value) { hCache.latency = value; }
    };

    /* OTAWA side (attributes/fields on icache type) */
    /*
    Integer o_block_bits  {
      Integer get() { return iCache.blockBits; 
}
      set(Integer value) { iCache.blockBits = value; }
    };

    Integer o_way_bits  {
      Integer get() { return iCache.wayBits; 
}
      set(Integer value) { iCache.wayBits = value; }
    };

    Integer o_row_bits  {
      Integer get() { return iCache.rowBits; 
}
      set(Integer value) { iCache.rowBits = value; }
    };

    Integer o_miss_penalty  {
      Integer get() { return iCache.missPenalty; 
}
      set(Integer value) { iCache.missPenalty = value; }
    };
    */

    /* ------------------- Sync directions -------------------------------
       Heptane -> OTAWA : map Heptane attributes to OTAWA icache fields
       OTAWA   -> Heptane: inverse mapping
       Optionally compute blockBits from cachelinesize using WcetMath.
       ------------------------------------------------------------------ */
   
      public setHeptaneField(String field, int value) {
  if (parameters.field == "nbsets")        { h_nbsets = parameters.value;
                                             log "h_nbsets: " + parameters.value;
                                             return; 
}
  if (parameters.field == "nbways")        { h_nbways = parameters.value;        return; 
}
  if (parameters.field == "cachelinesize") { h_cachelinesize = parameters.value; return; 
}
  if (parameters.field == "latency")       { h_latency = parameters.value;       return; 
}
  // (optionnel) lever une erreur si champ inconnu
}

    delete();
  
  }
  

  /* =====================================================================
     View concept to expose user-editable fields (UI/API) with sync hooks
     ===================================================================== */
  public concept CacheView  {

    /* Attach to the federation concept living in this VM */
    Cache syncCache with ConceptInstance(virtualModelInstance=container,container=this);
    


    /* User-facing properties (you can rename these labels for your UI) */
    
    Integer block_bits  {
      Integer get() { return syncCache.h_cachelinesize; 
}
      set(Integer value) { syncCache.h_cachelinesize = value; }
    };

    Integer way_bits  {
      Integer get() { return syncCache.h_nbways; 
}
      set(Integer value) { syncCache.h_nbways = value; }
    };

    Integer row_bits  {
      Integer get() { return syncCache.h_nbsets; 
}
      set(Integer value) { syncCache.h_nbsets = value; }
    };

    Integer miss_penalty  {
      Integer get() { return syncCache.h_latency; 
}
      set(Integer value) { syncCache.h_latency = value; }
    };

   

    delete();
  

  }
  
   public modifyCache(String side, String field, int value, boolean propagate) {
  if (parameters.side == "heptane") {
    cache.setHeptaneField(parameters.field,parameters.value);
    
}
  }


  /* Clean-up */
  
  delete();


  }
