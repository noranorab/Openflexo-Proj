namespace "file:/C:/Users/PC/Desktop/TelecomParis/internship%202A/" as _;

use org.openflexo.technologyadapter.xml.XMLModelSlot as XML;
use org.openflexo.foundation.fml.rt.FMLRTModelSlot as FMLRT;

import org.openflexo.foundation.fml.VirtualModel;
import org.openflexo.technologyadapter.xml.model.typed.XMLModel;
import org.openflexo.technologyadapter.xml.model.typed.XMLIndividual;
import org.openflexo.technologyadapter.xml.metamodel.XSDMetaModel;
import org.openflexo.technologyadapter.xml.metamodel.XMLComplexType;
import java.lang.String;
// import wcet.util.WcetMath;  // Uncomment if you actually use it

/* === XSD meta-models (URIs or file-based) ================================ */
/* OTAWA Cache XSD (icache / dcache). If you prefer local file, you can use:
   import XSDMetaModel OTAWA_CACHE from [_ + "xmlFiles/OtawaCache.xsd"];
*/

/* Heptane WCET XSD (CACHE element has named type HeptaneCacheType).
   If you prefer local file, use:
   import XSDMetaModel HEPTANE_WCET from [_ + "xmlFiles/HeptaneWCET.xsd"];
*/
import XSDMetaModel HEPTANE_CACHE   from ["http://mem4csd.telecom-paris.fr/HeptaneWCET"];
import XSDMetaModel OTAWA_CACHE    from ["http://mem4csd.telecom-paris.fr/OtawaCache"];
/* === XML complex types ==================================================== */
//import XMLComplexType CACHE_CONFIG  from [OTAWA_CACHE:"dcache"];

import XMLComplexType ICACHE_TYPE  from [OTAWA_CACHE:"icache"];
import XMLComplexType HCACHE_TYPE  from [HEPTANE_WCET:"HeptaneCacheType"];
import XMLComplexType CONFIGURATION_TYPE   from [HEPTANE_WCET:"CONFIGURATION"];
import XMLComplexType ARCHITECTURE_TYPE   from [HEPTANE_WCET:"ARCHITECTURE"];
import [_ + "HeptaneTool.fml"];
//import XMLComplexType CONFIG_TYPE from [OTAWA_CACHE:"CacheConfigType"];

/* === FML typedefs to make roles strongly typed =========================== */
typedef XMLIndividualType(xsdType=ARCHITECTURE_TYPE) as HeptaneCache;
typedef XMLIndividualType(xsdType=ARCHITECTURE_TYPE) as HeptaneConfiguration;
typedef XMLIndividualType(xsdType=ICACHE_TYPE) as OtawaICache;
typedef XMLIndividualType(xsdType=ARCHITECTURE_TYPE) as Architecture;

/* =========================================================================
   All-in-one VM: resources, roles, sync logic, and a small workflow API
   ========================================================================= */
@URI("file:/C:/Users/PC/Desktop/TelecomParis/internship%202A/WorkflowWCET.fml")
@Author("PC")
public model WorkflowWCET {

  /* ---- Bind the two XML instance resources (the actual XML files) ---- */
    XMLModel otawaCacheRes  with XMLModelSlot(metaModel=OTAWA_CACHE);
   XMLModel heptaneWCETRes with XMLModelSlot(metaModel=HEPTANE_CACHE);
  /* ---- Federation roles: the two cache individuals we synchronize ---- */
  XMLIndividual  hCache with XMLIndividualRole(container=heptaneWCETRes,xsdType=null);
  OtawaICache   iCache with XMLIndividualRole(container=otawaCacheRes,  xsdType=ICACHE_TYPE);
  XMLIndividual  configuration with XMLIndividualRole(container=heptaneWCETRes, xsdType=null );
    
  /* ---------------------------------------------------------------------
     Constructors / connectors
     --------------------------------------------------------------------- */

   CacheView cacheView with ConceptInstance(virtualModelInstance=this);
   Cache cache with ConceptInstance(virtualModelInstance=this);
  create(Resource<XMLModel> heptaneRes, Resource<XMLModel> otawaRes) {
    connect heptaneWCETRes using parameters.heptaneRes;
    connect otawaCacheRes  using parameters.otawaRes;
    //XMLIndividual arch = configuration.getPropertyValue("ARCHITECTURE");
    //iCache = (OtawaICache)otawaCacheRes.root.icache;
   // XMLIndividual config = otawaCacheRes.getIndividualWithUUID("otawa::hard::Cache");
   
   configuration =(HeptaneConfiguration)heptaneWCETRes.root;
   //hCache = configuration.architecture.caches;
//log "architecture: " + ARCHITECTURE;
    for (Object cache : configuration.architecture.caches) {
     hCache =cache;
}

  }

	
  /* =====================================================================
     Federation concept: canonical cache properties + sync methods
     ===================================================================== */
  public concept Cache {

    
    /* Heptane side (attributes on <CACHE .../>) */
    
    Integer h_nbsets  {
      Integer get() { return hCache.nbsets; 
}
      set(Integer value) { hCache.nbsets = value; }
    };

    Integer h_nbways  {
      Integer get() { return hCache.nbways; 
}
      set(Integer value) { hCache.nbways = value; }
    };

    Integer h_cachelinesize  {
      Integer get() { return hCache.cachelinesize; 
}
      set(Integer value) { hCache.cachelinesize = value; }
    };

    Integer h_latency  {
      Integer get() { return hCache.latency; 
}
      set(Integer value) { hCache.latency = value; }
    };

    /* OTAWA side (attributes/fields on icache type) */
    
    Integer o_block_bits  {
      Integer get() { return iCache.blockBits; 
}
      set(Integer value) { iCache.blockBits = value; }
    };

    Integer o_way_bits  {
      Integer get() { return iCache.wayBits; 
}
      set(Integer value) { iCache.wayBits = value; }
    };

    Integer o_row_bits  {
      Integer get() { return iCache.rowBits; 
}
      set(Integer value) { iCache.rowBits = value; }
    };

    Integer o_miss_penalty  {
      Integer get() { return iCache.missPenalty; 
}
      set(Integer value) { iCache.missPenalty = value; }
    };

    /* ------------------- Sync directions -------------------------------
       Heptane -> OTAWA : map Heptane attributes to OTAWA icache fields
       OTAWA   -> Heptane: inverse mapping
       Optionally compute blockBits from cachelinesize using WcetMath.
       ------------------------------------------------------------------ */

    public syncHeptaneToOtawa() {
      // If you want math: o_block_bits = WcetMath.blockBitsFromCacheLineSize(h_cachelinesize);
      o_block_bits   = h_cachelinesize;  // direct mapping for now
      o_way_bits     = h_nbways;
      o_row_bits     = h_nbsets;
      o_miss_penalty = h_latency;
    }

    public syncOtawaToHeptane() {
      // If you want math: h_cachelinesize = WcetMath.cacheLineSizeFromBlockBits(o_block_bits);
      h_cachelinesize = o_block_bits;   // direct mapping for now
      h_nbways        = o_way_bits;
      h_nbsets        = o_row_bits;
      h_latency       = o_miss_penalty;
    }
      public setHeptaneField(String field, int value) {
  if (parameters.field == "nbsets")        { h_nbsets = parameters.value;
                                             log "h_nbsets: " + parameters.value;
                                             return; 
}
  if (parameters.field == "nbways")        { h_nbways = parameters.value;        return; 
}
  if (parameters.field == "cachelinesize") { h_cachelinesize = parameters.value; return; 
}
  if (parameters.field == "latency")       { h_latency = parameters.value;       return; 
}
  // (optionnel) lever une erreur si champ inconnu
}

/* Définir/modifier un champ côté OTAWA */
public setOtawaField(String field, int value) {
  if (parameters.field == "block_bits")   { o_block_bits = parameters.value;   return; 
}
  if (parameters.field == "way_bits")     { o_way_bits = parameters.value;     return; 
}
  if (parameters.field == "row_bits")     { o_row_bits = parameters.value;     return; 
}
  if (parameters.field == "miss_penalty") { o_miss_penalty = parameters.value; return; 
}
  // (optionnel) lever une erreur si champ inconnu
}
   
    delete();
  
  }
  

  /* =====================================================================
     View concept to expose user-editable fields (UI/API) with sync hooks
     ===================================================================== */
  public concept CacheView  {

    /* Attach to the federation concept living in this VM */
    Cache syncCache with ConceptInstance(virtualModelInstance=container,container=this);
    


    /* User-facing properties (you can rename these labels for your UI) */
    
    Integer block_bits  {
      Integer get() { return syncCache.h_cachelinesize; 
}
      set(Integer value) { syncCache.h_cachelinesize = value; }
    };

    Integer way_bits  {
      Integer get() { return syncCache.h_nbways; 
}
      set(Integer value) { syncCache.h_nbways = value; }
    };

    Integer row_bits  {
      Integer get() { return syncCache.h_nbsets; 
}
      set(Integer value) { syncCache.h_nbsets = value; }
    };

    Integer miss_penalty  {
      Integer get() { return syncCache.h_latency; 
}
      set(Integer value) { syncCache.h_latency = value; }
    };

    /* Push user edits -> XMLs (Heptane then OTAWA) */
    
    public syncToXml() {
      // If using math helpers, you could compute here before pushing
      syncCache.syncHeptaneToOtawa();
    }

    /* Pull from XMLs -> refresh the view fields */
    
    public syncFromXml() {
      syncCache.syncOtawaToHeptane();
      this.block_bits   = syncCache.h_cachelinesize;
      this.way_bits     = syncCache.h_nbways;
      this.row_bits     = syncCache.h_nbsets;
      this.miss_penalty = syncCache.h_latency;
    }

    delete();
  

  }
  /* =====================================================================
     Minimal workflow helpers
     ===================================================================== */

  /* Create a view pre-wired to the current VM */
  
  public CacheView createCacheView() {
    cacheView.syncFromXml();
  return cacheView;
 
  }

  /* Convenience workflow steps (optional) */
  
  public synchronizeHeptaneToOtawa() {
    
    cache.syncHeptaneToOtawa();
  }

  public synchronizeOtawaToHeptane() {
    
    cache.syncOtawaToHeptane();
  }
   public modifyCache(String side, String field, int value, boolean propagate) {
  if (parameters.side == "heptane") {
    cache.setHeptaneField(parameters.field,parameters.value);
    if (parameters.propagate) { cache.syncHeptaneToOtawa(); 
}
  }
  else { // assume "otawa"
    cache.setOtawaField(parameters.field,parameters.value);
    if (parameters.propagate) { cache.syncOtawaToHeptane(); 
}
  }

}
  /* Clean-up */
  
  delete();


  }
