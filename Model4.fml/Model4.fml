use org.openflexo.technologyadapter.xml.XMLModelSlot as XML;

import org.openflexo.technologyadapter.xml.model.typed.XMLModel;
import org.openflexo.technologyadapter.xml.metamodel.XSDMetaModel;
import org.openflexo.technologyadapter.xml.model.typed.XMLIndividual;
import org.openflexo.technologyadapter.xml.metamodel.XMLComplexType;
import java.lang.String;

// XSD files import
import XSDMetaModel HEPTANE_WCET from ["http://mem4csd.telecom-paris.fr/HeptaneWCET"];
import XSDMetaModel OTAWA_CACHE  from ["http://mem4csd.telecom-paris.fr/OtawaCache"];
import XSDMetaModel OTAWA_MEMORY from ["http://mem4csd.telecom-paris.fr/OtawaMemory"];

// The complex types found in XSD files
import XMLComplexType HEPTANE_CACHE_TYPE from [HEPTANE_WCET:"HeptaneCacheType"];
import XMLComplexType DCACHE_TYPE        from [OTAWA_CACHE:"dcache"];

// Types beeing made available at FML level, built using XSD types found in XSD files
typedef XMLIndividualType(xsdType=DCACHE_TYPE) as HCache;
typedef XMLIndividualType(xsdType=DCACHE_TYPE)        as DCache;

/**
 * This virtual model defines the federation of two XML files :
 * - heptane XML file
 * - Otawa cache file
 */
@URI("file:/C:/Users/PC/Desktop/TelecomParis/internship%202A/Model4.fml")
model Model4 {
  // The two model slots defining links to XML files
  XMLModel heptane with XMLModelSlot(metaModel=null);
  XMLModel otawa   with XMLModelSlot(metaModel=null);

  // A basic constructor based on the explicit given of the two resources
  create(Resource<XMLModel> heptaneResource, Resource<XMLModel> otawaResource) {
    connect heptane using parameters.heptaneResource;
    connect otawa   using parameters.otawaResource;
    // Call the synchronization at the end of constructor, to initialize instances
    this.synchronize();
  }

  /**
   * A concept demonstrating link etablishment between cache in Heptane and cache in Otawa
   */
  public concept Cache {

    XMLIndividual hCache with XMLIndividualRole(container=heptane, xsdType=null);
    XMLIndividual dCache with XMLIndividualRole(container=otawa,   xsdType=null);

    // If we have only the Heptane instance
    create::initFromHCache(HCache anHCache) {
      hCache = parameters.anHCache;
    }

    // If we have both sides
    create::createFromBoth(HCache h, DCache d) {
      hCache = parameters.h;
      dCache = parameters.d;
    }

    delete::performDelete() {
    }
  }

  // Synchronize instances of Cache with all instances found in Heptane file
   public synchronize() {
      MatchingSet<Cache> matchingSet = begin match Cache from this;

      for (HCache h : select HCache from heptane) {

         DCache d = this.findMatchingDCache(h);
         if (d != null) {
           match Cache
              in matchingSet from this
              where (hCache=h,dCache=d)
              create::createFromBoth(h,d);
         }
         else {
            match Cache
               in matchingSet from this
               where (hCache=h)
               create::initFromHCache(h);
            
         }
      }

      // TODO: may be we need to match some other DCache ????
     for (DCache d : select DCache from otawa) {
       // TODO... 
     
}

     end match Cache in matchingSet delete::performDelete();

   }

  /**
   * Semantic rule (log2) matcher:
   * Heptane.nbsets        == 2^(OTAWA.row_bits)
   * Heptane.nbways        == 2^(OTAWA.way_bits)
   * Heptane.cachelinesize == 2^(OTAWA.block_bits)
   * Heptane.latency       == OTAWA.miss_penalty
   */
  public DCache findMatchingDCache(HCache h) {
    Integer h_nbsets        = h.nbsets;
    Integer h_nbways        = h.nbways;
    Integer h_cachelinesize = h.cachelinesize;
    Integer h_latency       = h.latency;

    for (DCache d : select DCache from otawa) {
      Integer d_row_bits     = d.row_bits;
      Integer d_way_bits     = d.way_bits;
      Integer d_block_bits   = d.block_bits;
      Integer d_miss_penalty = d.miss_penalty;

      Integer calc_nbsets        = 1 << d_row_bits;
      Integer calc_nbways        = 1 << d_way_bits;
      Integer calc_cachelinesize = 1 << d_block_bits;

      if ( h_nbsets == calc_nbsets && h_nbways == calc_nbways && h_cachelinesize == calc_cachelinesize && h_latency == d_miss_penalty ) {
        return d;
      }
    }
    return null;
  }
}
